---
title: "Writing Tests"
description: "Learn how to write effective TestDriver tests with natural language"
icon: "pencil"
---

## Instructions for Coding Agents

We recommend starting with [our quickstart](./quickstart) then supplying your coding agent with our [agents.md](https://github.com/testdriverai/testdriverai/agents.md) file.

Then, you can prompt your coding agent to generate tests:

```md
Make me a TestDriver test that does the following steps:

Navigate to practicetestautomation.com
Type username student into Username field
Type password Password123 into Password field
Push Submit button
Verify new page contains expected text 'logged in'
```

## AI Exploration Mode

Within a test, the `ai()` method lets TestDriver autonomously figure out how to accomplish a task. It's useful for dynamic or unpredictable UIs where explicit actions may be difficult to define.

```javascript
// Handle dynamic or unpredictable UI
await testdriver.ai('dismiss any popups or modals that appear');
```

<Info>Explicit commands are preferred for production tests, as they are cheaper, faster, and more reliable.</Info>

## Locating Single Elements

Use natural language to describe elements. Descriptions should be specific enough to locate the element, but not too-specific that they break with minor UI changes. For example:

```javascript
await testdriver.find('email input field');
await testdriver.find('first product card in the grid');
await testdriver.find('dropdown menu labeled "Country"');
```

<Info>TestDriver will cache found elements for improved performance on subsequent calls. Learn more about [element caching here](/v7/features/fast).</Info>

## Debugging Found Elements

After finding an element, you can inspect its properties for debugging:

```javascript
const button = await testdriver.find('submit button');
console.log(button);
```

This outputs all element properties:

```javascript
{
  description: 'submit button',
  found: true,
  x: 150,
  y: 300,
  coordinates: { x: 150, y: 300, centerX: 200, centerY: 320 },
  threshold: 0.8,
  confidence: 0.95,
  similarity: 0.92,
  selector: 'button[type="submit"]',
  cache: {
    hit: true,
    strategy: 'pixel-diff',
    createdAt: '2025-01-15T10:30:00Z',
    diffPercent: 0.02,
    imageUrl: 'https://...'
  }
}
```

## Performing Actions

TestDriver provides a variety of actions you can perform, like [clicking](/v7/api/click), [typing](/v7/api/type), [hovering](/v7/api/hover), and [scrolling](/v7/api/scroll). For a full list, see the [API Reference](/v7/api/click).

```javascript
// Clicking
await testdriver.find('submit button').click();
await testdriver.find('file item').doubleClick();
await testdriver.find('text area').rightClick();

// Typing
await testdriver.find('email input').type('user@example.com');
await testdriver.find('password input').type('secret', { secret: true });

// Keyboard shortcuts
await testdriver.pressKeys(['enter']);
await testdriver.pressKeys(['ctrl', 'c']);

// Hovering
await testdriver.find('dropdown menu').hover();

// Scrolling
await testdriver.scroll('down', 500);
await testdriver.scrollUntilText('Footer content');
```

## Chaining Actions

TestDriver supports method chaining for cleaner code:

```javascript
// Chain find() with actions
const button = await testdriver.find('submit button').click();```
```

Or save element reference for later use:

```javascript
const button = await testdriver.find('submit button');
await button.click();
```

## Making Assertions

Use AI-powered assertions to verify application state:

```javascript
// Verify visibility
await testdriver.assert('login page is displayed');
await testdriver.assert('submit button is visible');
await testdriver.assert('loading spinner is not visible');

// Verify content
await testdriver.assert('page title is "Welcome"');
await testdriver.assert('success message says "Account created"');
await testdriver.assert('error message contains "Invalid email"');

// Verify state
await testdriver.assert('checkbox is checked');
await testdriver.assert('dropdown shows "United States"');
await testdriver.assert('button is disabled');

// Verify visual appearance
await testdriver.assert('submit button is blue');
await testdriver.assert('form has red border');
```

<Info>Assertions are not cached and always re-evaluated to ensure accuracy.</Info>

## Waiting for Elements

Use the `timeout` option with `find()` to wait for elements that appear after async operations:

```javascript
// Wait up to 30 seconds for element to appear (polls every 5 seconds)
const element = await testdriver.find('Loading complete indicator', { timeout: 30000 });
await element.click();

// Useful after actions that trigger loading states
await testdriver.find('submit button').click();
await testdriver.find('success message', { timeout: 15000 });

// Short timeout for quick checks
const toast = await testdriver.find('notification toast', { timeout: 5000 });
```

## Working with Multiple Elements

Find and interact with multiple elements:

```javascript
// Find all matching elements
const products = await testdriver.findAll('product card');
console.log(`Found ${products.length} products`);

// Interact with each
for (const product of products) {
  const title = await product.find('title text');
  console.log('Product:', title.text);

  await product.find('add to cart button').click();
}

// Or find specific element
const firstProduct = products[0];
await firstProduct.click();
```

## Flake Prevention

TestDriver automatically waits for the screen and network to stabilize after each action using **redraw detection**. This prevents flaky tests caused by animations, loading states, or dynamic content updates.

<Note>
  Redraw detection adds a small delay after each action but significantly reduces test flakiness.
</Note>

For example, when clicking a submit button that navigates to a new page:

```javascript
// Click submit - TestDriver automatically waits for the new page to load
await testdriver.find('submit button').click();

// By the time this runs, the page has fully loaded and stabilized
await testdriver.assert('dashboard is displayed');
await testdriver.find('welcome message');
```

Without redraw detection, you'd need manual waits or retries to handle the page transition. TestDriver handles this automatically by detecting when the screen stops changing and network requests complete.

You can disable redraw detection or customize its behavior:

```javascript
// Disable redraw detection for faster tests (less reliable)
const testdriver = TestDriver(context, { 
  redraw: false 
});
```

Here is an example of customizing redraw detection:

```javascript
// Fine-tune redraw detection
const testdriver = TestDriver(context, { 
  redraw: {
    enabled: true,
    diffThreshold: 0.1,      // Pixel difference threshold (0-1)
    screenRedraw: true,      // Monitor screen changes
    networkMonitor: true,    // Wait for network idle
  }
});
```
