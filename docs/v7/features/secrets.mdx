---
title: "Using Secrets"
description: "Use dynamic data and secure secrets in your tests"
icon: "key"
---

Scale your testing with dynamic data and secure secrets management.

## Dynamic Variables for Data-Driven Tests

Scale your testing with dynamic data to cover more scenarios:

<Tabs>
  <Tab title="Environment Variables">
    ```javascript
    import { test } from 'vitest';
    import { chrome } from 'testdriverai/presets';

    test('multi-environment testing', async (context) => {
      const env = process.env.TEST_ENV || 'staging';
      const urls = {
        dev: 'https://dev.myapp.com',
        staging: 'https://staging.myapp.com',
        production: 'https://myapp.com'
      };

      const { testdriver } = await chrome(context, { 
        url: urls[env] 
      });

      await testdriver.assert('app is running');
    });
    ```

    ```bash
    # Run against different environments
    TEST_ENV=dev npx vitest run
    TEST_ENV=staging npx vitest run
    TEST_ENV=production npx vitest run
    ```
  </Tab>

  <Tab title="Test Fixtures">
    ```javascript test/fixtures/users.js
    export const testUsers = [
      { email: 'admin@test.com', role: 'admin' },
      { email: 'user@test.com', role: 'user' },
      { email: 'guest@test.com', role: 'guest' }
    ];

    export const products = [
      { name: 'Laptop', price: 999 },
      { name: 'Mouse', price: 29 },
      { name: 'Keyboard', price: 89 }
    ];
    ```

    ```javascript test/permissions.test.js
    import { test } from 'vitest';
    import { chrome } from 'testdriverai/presets';
    import { testUsers } from './fixtures/users.js';

    test.each(testUsers)('$role can access dashboard', async ({ email, role }, context) => {
      const { testdriver } = await chrome(context, { url });
      
      await testdriver.find('email input').type(email);
      await testdriver.find('password input').type('password123');
      await testdriver.find('login button').click();
      
      if (role === 'admin') {
        await testdriver.assert('admin panel is visible');
      } else {
        await testdriver.assert('user dashboard is visible');
      }
    });
    ```
  </Tab>

  <Tab title="Dynamic Data Generation">
    ```javascript
    import { test } from 'vitest';
    import { chrome } from 'testdriverai/presets';
    import { faker } from '@faker-js/faker';

    test('user registration with dynamic data', async (context) => {
      const { testdriver } = await chrome(context, { url });

      // Generate unique test data for each run
      const userData = {
        firstName: faker.person.firstName(),
        lastName: faker.person.lastName(),
        email: faker.internet.email(),
        password: faker.internet.password({ length: 12 })
      };

      await testdriver.find('first name input').type(userData.firstName);
      await testdriver.find('last name input').type(userData.lastName);
      await testdriver.find('email input').type(userData.email);
      await testdriver.find('password input').type(userData.password);
      await testdriver.find('register button').click();

      await testdriver.assert('registration successful');
      console.log('Registered user:', userData.email);
    });
    ```

    ```bash
    npm install --save-dev @faker-js/faker
    ```
  </Tab>
</Tabs>

<Card title="Dynamic Variables Best Practices" icon="lightbulb">
  - **Environment configs:** Store URLs, credentials, and settings in env vars
  - **Test fixtures:** Maintain reusable test data in separate files
  - **Data generators:** Use libraries like Faker for unique test data
  - **Parameterization:** Test multiple scenarios with `test.each()`
  - **CI/CD integration:** Pass dynamic values via environment variables
</Card>
